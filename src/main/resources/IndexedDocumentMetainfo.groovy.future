package nz.ac.auckland.pcf.search

import nz.ac.auckland.pcf.search.elastic.MarkupConvertor
import nz.ac.auckland.search.IndexedField
import org.slf4j.Logger
import org.slf4j.LoggerFactory

import java.lang.reflect.Field
import java.lang.reflect.Method
import java.lang.reflect.Modifier


class IndexedDocumentMetainfo{
    public static Logger log = LoggerFactory.getLogger(IndexedDocumentMetainfo.class);

    MarkupConvertor markupConvertor = null

    Map<String, IndexedField> sanityCheckCache = [:]
    Map<Method, IndexedField> annotatedMethods = [:]
    Map<Field, IndexedField> annotatedFields = [:]

    public IndexedDocumentMetainfo(Class clazz, MarkupConvertor markupConvertor){
        this.markupConvertor = markupConvertor

        // cache all annotated methods of interest
        // if method looks like getter, put field name into sanityCheckCache
        clazz.getDeclaredMethods().each {Method method->
            IndexedField annotation = method.getAnnotation(IndexedField)
            if (annotation){
                if (Modifier.isPrivate(method.getModifiers())){
                    log.warn("Private methods aren't supported: ${clazz.getSimpleName()}.${method.getName()}")
                }else if (method.getGenericParameterTypes().size()>0) {
                    log.warn("Methods with arguments aren't supported: ${clazz.getSimpleName()}.${method.getName()}");
                }else{
                    annotatedMethods.put(method, annotation)

                    String name = method.getName()
                    if (name.startsWith("get") && name.size()>3){
                        String fieldName = name.substring(3)
                        // lower case first char
                        fieldName = fieldName.substring(0,1).toLowerCase()+fieldName.substring(1)
                        if (sanityCheckCache.put(fieldName, annotation)!=null){
                            log.warn("Two getters for same field ?? (${method.getName()})")
                        }
                    }
                }
            }
        }

        // cache all annotated field of interest
        // if sanityCheckCache already contains this name, make a warning
        //   that getter for this field is also annotated
        clazz.getDeclaredFields().each {Field field->
            IndexedField annotation = field.getAnnotation(IndexedField)
            if (annotation){
                if (Modifier.isPrivate(field.getModifiers())){
                    field.setAccessible(true)
                    log.warn("Accessing private field of ${clazz.getSimpleName()}.${field.getName()}")
                }
                annotatedFields.put(field, annotation)

                String name = field.getName()
                IndexedField existing = sanityCheckCache.get(name)
                if (existing){
                    if (existing.indexFieldName()!=annotation.indexFieldName()){
                        log.warn("Possible mistake. Both field $name and its getter are annotated.")
                    }else if (existing.markupPresent()==annotation.markupPresent()){
                        // absolutely same annotations
                        log.warn("Duplicate annotation on the field $name and its getter. May result in duplicate data in the index (field ${annotation.indexFieldName()})")
                    } // same indexFieldName but different markup flag is very likely intended behaviour
                }
            }
        }
    }

    public Map<String, ?> convertObject(Object object){

        Map<String, ?> result = [:]
        annotatedMethods.each{Method method, IndexedField annotation ->
            try {
                Object value = method.invoke(object, null)
                processValue(value, annotation, result)
            }catch(Throwable e){
                log.error(e.getMessage(), e)
            }
        }

        annotatedFields.each {Field field, IndexedField annotation ->
            try {
                Object value = field.get(object)
                processValue(value, annotation, result)
            }catch(Throwable e){
                log.error(e.getMessage(), e)
            }
        }
        return result
    }

    protected processValue(Object value, IndexedField annotation, Map<String, ?> into){
        if (value && annotation.markupPresent())
            value = getNakedText(value)

        if (value){
            addField(annotation.indexFieldName(), value, into)
        }
    }

    protected void addField(String indexedFieldName, def fieldValue, Map<String, ?> into){
        if (!fieldValue) return
        def value = fieldValue
        if (fieldValue instanceof Collection){
            if (fieldValue instanceof Map){
                throw new Exception ("Maps aren't supported")
            }
            value = fieldValue as List
        }

        if (into.containsKey(indexedFieldName)){
            // if not array, convert to array and add to it
            def existing = into.get(indexedFieldName)
            if (!(existing instanceof List)){
                existing = [existing] as List
                into.put(indexedFieldName, existing)
            }

            if (value instanceof Collection)
                existing.addAll(value)
            else
                existing << value
        }else{
            into.put(indexedFieldName, value)
        }
    }

    protected String getNakedText(def value){
        if (!value) return null
        String str = markupConvertor.convertToText(value as String)
        if (!str.trim().equals('.') && !str.trim().isEmpty()){
            return str
        }else{
            return null
        }
    }

}
